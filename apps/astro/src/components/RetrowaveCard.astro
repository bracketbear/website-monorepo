---
interface Props {
  className?: string;
}

const { className = "" } = Astro.props;
---

<div class={`neon-card group scroll-animate ${className}`}>
  <div
    class="neon-glow absolute -inset-[2px] -z-10 rounded-lg opacity-75 blur-[2px] transition-all duration-300 group-hover:opacity-100 group-hover:blur-[3px]"
  >
  </div>
  <div class="retrowave-shine"></div>
  <slot />
</div>

<style>
  /* Retrowave neon card styling */
  .neon-card {
    position: relative;
    background: rgba(15, 7, 25, 0.65);
    border: 1px solid rgba(247, 37, 133, 0.5);
    box-shadow:
      0 0 5px rgba(247, 37, 133, 0.5),
      0 4px 15px rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    overflow: hidden;
    transition: all 0.5s ease;
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    padding: 0.75rem;
    /* Items are visible by default now */
    opacity: 1;
    transform: translateY(0);
  }

  /* Enhanced neon glow effect - no animation, will be controlled by scroll */
  .neon-glow {
    background: linear-gradient(
      45deg,
      rgba(255, 0, 98, 0.7) 0%,
      rgba(123, 31, 162, 0.7) 25%,
      rgba(76, 0, 255, 0.7) 50%,
      rgba(32, 178, 170, 0.7) 75%,
      rgba(255, 0, 98, 0.7) 100%
    );
    background-size: 400% 400%;
    opacity: 0.6;
    /* Animation removed - will be controlled by scroll */
  }

  /* Retrowave shine effect - no animation, will be controlled by scroll */
  .retrowave-shine::before {
    content: "";
    position: absolute;
    top: 0;
    left: -150%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      to right,
      rgba(255, 255, 255, 0) 0%,
      rgba(255, 255, 255, 0.1) 50%,
      rgba(255, 255, 255, 0) 100%
    );
    transform: rotate(45deg);
    /* Animation removed - will be controlled by scroll */
  }
</style>

<script>
  document.addEventListener("astro:page-load", () => {
    const cards = document.querySelectorAll(".scroll-animate");
    const totalScrollHeight =
      document.documentElement.scrollHeight - window.innerHeight;

    // Set initial animation state of components that are already visible
    updateElementsInViewport();

    // Add scroll listener to update animations based on scroll position
    window.addEventListener("scroll", () => {
      // Throttle the scroll event to improve performance
      if (!window.requestAnimationFrame) {
        updateElementsInViewport();
      } else {
        window.requestAnimationFrame(updateElementsInViewport);
      }
    });

    // Update each card's animation based on its position in viewport
    function updateElementsInViewport() {
      // Get current scroll position and document dimensions
      const scrollPosition = window.scrollY;
      const scrollPercentage = Math.min(
        1,
        Math.max(0, scrollPosition / totalScrollHeight)
      );

      cards.forEach((card) => {
        // Calculate card position relative to viewport
        const rect = card.getBoundingClientRect();
        const isInView = rect.top < window.innerHeight && rect.bottom > 0;

        if (isInView) {
          // Calculate how far the element is through the viewport (0-1)
          const elementScrollProgress = 1 - rect.top / window.innerHeight;
          const elementProgress = Math.min(
            1,
            Math.max(0, elementScrollProgress)
          );

          // Apply combined scroll effects
          applyScrollEffects(card, elementProgress, scrollPercentage);
        }
      });
    }

    // Apply specific animation effects based on scroll position
    function applyScrollEffects(element, elementProgress, globalProgress) {
      // Get elements to animate
      const glow = element.querySelector(".neon-glow");
      const shine = element.querySelector(".retrowave-shine")?.firstChild;

      if (!glow || !shine) return;

      // Calculate color gradient position (0-100%)
      // Combine both element progress and global scroll for more dynamic effect
      const colorPosition = Math.min(
        100,
        Math.max(0, elementProgress * 50 + globalProgress * 50)
      );
      glow.style.backgroundPosition = `${colorPosition}% 50%`;

      // Calculate shine position from -150% to 150% based on element progress
      const shinePosition = -150 + elementProgress * 300;
      shine.style.left = `${shinePosition}%`;

      // Adjust glow intensity based on element position
      const opacityValue = 0.4 + elementProgress * 0.3;
      const blurValue = 2 + elementProgress * 2;
      glow.style.opacity = opacityValue.toString();
      glow.style.filter = `blur(${blurValue}px)`;
    }
  });
</script>
